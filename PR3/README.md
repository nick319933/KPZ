# Практичне заняття №2
---
## Тема: Комплексне дослідження структури, конфігурацій та робочого середовища сучасного JavaScript-проєкту на основі бойлерплейта vite-react-boilerplate

## Зміст
1. [Початкова підготовка середовища](#початкова-підготовка-середовища)
2. [Аналіз структури файлу `package.json`](#аналіз-структури-файлу-packagejson)
3. [Семантичне версіонування (SemVer)]()
4. [Дослідження додаткових конфігураційних файлів]()
5. [Аналіз роботи гіт-хуків Husky]()
6. [Використання змінних оточення]()

---
## Початкова підготовка середовища
1. Склонуйте репозиторій `vite-react-boilerplate`.
2. Встановіть усі залежності проєкту:
```bash
pnpm install
```
3. Запустіть початковий скрипт сетапу проєкту:
```bash
pnpm run setup
```


## Аналіз структури файлу package.json

1. Опишіть призначення полів файлу `package.json`:
	- `name`: Унікальне ім'я проєкту для npm.
	- `author`: Ім'я, email автора.
	- `description`: Невеликий опис проєкту.
	- `repository`: Посилання на репозиторій (URL).
	- `license`: Ліцензія, яка визначає умови використання.
	- `version`: Версія (SemVer).
	- `scripts`: Команди автоматизації (`dev`, `build`).
	- `dependencies`: Бібліотеки, які необхідні для роботи проєкту в продакшені.
	- `devDependencies`: Бібліотеки, які необхідні для розробки та тестування.

2. Проаналізуйте залежності у `dependencies` та `devDependencies`, поясніть логіку їх класифікації.
	- `dependencies`
		Бібліотеки для роботи проєкту в продакшені: 
		- Основні бібліотеки React: `react`, `react-dom`.
		- Форми та валідація: `react-hook-form`, `@hookform/resolvers`, `zod`.
		- Роутінг та API-запити: `@tanstack/react-router`, `@tanstack/react-query`.
		- Таблиці та візуалізація даних: `@tanstack/react-table`, `@nivo/core`, `@nivo/bar`, `@nivo/line`, `@nivo/pie`.
		- Інтерналізація: `i18next`, `react-i18next`, `i18next-browser-languagedetector`, `i18next-http-backend`.
		- Работа з датами: `dayjs`.
		- Управління станом: `zustand`.

	-  `devDependencies`
		Інструменти для розробки та тестування:
		- Тестування: `vitest`, `@testing-library/*`, `@playwright/test`.
		- Storybook: `@storybook/*`.
		- Лінтінг та форматування: `eslint`, `prettier`, `typescript-eslint`.
		- Стилізація: `tailwindcss`, `postcss`, `@headlessui/react`, `@heroicons/react`.
		- Збірка: `vite`, `vite-plugin-static-copy`, `@vitejs/plugin-react-swc`.
		- DevTools: `@hookform/devtools`, `@tanstack/*-devtools`, `@faker-js/faker`.
		- Комміти та CI: `husky`, `commitizen`, `commitlint`, `cz-conventional-changelog`.
		- Типізація: `typescript`, `@types/*`.

	- Логіка класифікації
		- `dependencies`: Для функціонування продакшен версій проекту.
		- `devDependencies`: Для розробки, тестування, збірки, яке не включаються в продакшен, щоб зменшити розмір збірки.


## Семантичне версіонування (SemVer)
1. Ознайомтесь із [принципами SemVer](https://semver.org/).
2. Дослідіть версії пакетів бойлерплейту. Поясніть, які оновлення (мажорні, мінорні, патчі) допускаються відповідно до версій, зазначених у файлі `package.json`.
	-  У файлі `package.json` версії пакетів записані у форматі семантичного версіонування (`<major>.<minor>.<patch>`). 
	- Існують спеціальні префікси, які вказують, які оновлення допустимі автоматично при встановленні через `npm install`.
		- `^` - Будь-яке мінорне або патч-оновлення, але не мажорне. Приклад: `"tailwindcss": "^3.4.10"`.
		- Без префіксу - Допускається тільки ця версія. Приклад: `"vite": "5.4.2"`.


## Дослідження додаткових конфігураційних файлів
1. Проаналізуйте та опишіть призначення, структуру та важливі елементи файлів:
	- `README.md`
		- Призначення:
			- Файл `README.md` слугує основним джерелом інформації про проєкт.
		- Структура:
			- Назва
			- Логотип
			- Зміст ("Огляд", "Вимоги", "Початок роботи", "Тестування", "Підготовка до розгортання", "DevTools" та "Встановлені пакети")
			- Огляд: Підкреслює акцент на типобезпеці, масштабованості та зручності для розробника.
			- Початок роботи: Надає покрокові інструкції з клонування репозиторію, встановлення залежностей та ініціалізації проєкту.
			- Тестування: Описує інтегровані інструменти для тестування, такі як Vitest, React Testing Library та Playwright.
		    - DevTools: Перелік інструментів для розробки, включаючи TanStack Query Devtools, TanStack Router Devtools, TanStack Table Devtools та React Hook Form Devtools.
			- Інші: Згадуються додаткові бібліотеки, такі як i18next, react-i18next, ts-reset, Faker та Dayjs.
		- Ключові елементи:
			- Чіткий опис призначення проєкту.
			- Детальні інструкції з встановлення та запуску.
			- Перелік інтегрованих інструментів та бібліотек.
		    - Посилання на додаткову документацію або ресурси.
	- `.gitignore`
		- Призначення:
			- Файл `.gitignore` визначає, які файли та каталоги слід ігнорувати системі контролю версій Git.
		- Структура:
			- Логи: `logs`, `*.log`.
			- Залежності/збірки: `node_modules`, `dist`.
			- Редактори: `.vscode/*` (крім `extensions.json`, `launch.json`), `.idea`, `.DS_Store`.
			- Тести: `test-results/`, `coverage/`, `playwright-report/`.
		- Ключові елементи:
			- Ігнорування каталогів та файлів, що не повинні бути у репозиторії(логи, збірки, тести, конфігурації редакторів).
			- Забезпечення безпеки, уникаючи додавання конфіденційних даних.
	- `LICENSE`
		- Призначення:
			- Файл `LICENSE` визначає умови ліцензування проєкту, вказуючи, як інші можуть використовувати, змінювати та поширювати код.
		- Структура:
			- Репозиторій використовує ліцензію MIT, яка є однією з найпоширеніших та найменш обмежувальних ліцензій.
				- Назва: MIT License.
				- Автор: Copyright (c) 2023 RicardoValdovinos.
				- Умови: Дозволяє використання, модифікацію, поширення з вимогою збереження авторських прав.
				- Відмова: Без гарантій, автор не несе відповідальності.
		- Важливі елементи:
			- Захист автора.


## Аналіз роботи гіт-хуків Husky
1. Дослідіть артефакти, які створюються після встановлення та налаштування бібліотеки Husky.
	- Артефакти
		- Головна директорія `.husky/`
			- `husky.sh`
			- `prepare-commit-msg`
			- `commit-msg`
			- `pre-commit`, `pre-push`, `post-merge`, ...
2. Опишіть, для чого потрібні ці артефакти, як вони налаштовуються та яку роль відіграють у процесі розробки.
	- `husky.sh`: Забезпечує сумісність хуків; додається автоматично (`npx husky init`).
	- `prepare-commit-msg`: Запускає Commitizen для стандартизованих комітів; налаштовується з допомогою `"commitizen"` у файлі `package.json`.
	- `commit-msg`: Перевіряє формат комітів; налаштовується з допомогою `"commitlint"`у файлі `package.json`.
	- `pre-commit`, `pre-push`, ... : Для додаткових перевірок; налаштування відбувається вручну.
	- **`.gitignore`**: Ігнорує файли.

	- Роль у розробці:
		- Автоматизують перевірку форматів комітів, тестів.
		- Забезпечують єдиний стиль комітів.
		- Покращують якість коду.



## Використання змінних оточення
1. Напишіть скрипт, який буде читати довільну змінну оточення та друкувати її значення у консоль.
	![[Screenshot from 2025-05-08 14-11-02.png]]
2. Задайте різне значення змінної оточення на різних рівнях (ОС, сесія терміналу, окремий запуск скрипта, dotEnv файл) та дослідіть пріоритетність їх застосування.
	1. Системна змінна ОС
		![[Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-07-20.png)
		![Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-00-29.png)
	2. Сесія терміналу
		![Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-01-55.png)
	3. Окремий запуск скрипта
		![Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-03-40.png)
	4. `.env` файл
		![Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-05-25.png)
		![Screenshot](https://github.com/nick319933/KPZ/blob/main/PR3/screenshots/Screenshot%20from%202025-05-08%2014-16-48.png)
